// // BASIC IDEA
// int number;
// int divisor = 0;
// float quotient = FLOAT_MAX;
// char prevQuotient;
// do {
// 		divisor++;
// 		prevQuotient = quotient
// 		quotient = divide(number, divisor);
// } while (quotient > divisor) 
// return (divisor-quotient) > (prevQuotient - (divisor-1)) ? divisor-1 : divisor;


// // C-code with an input represented in two separate parsts; most significant and least significant 8 bits
// // char is 1 byte (8 bits)
// char mostSig, leastSig; 
// char divisor;
// char mostSigQuotient, leastSigQuotient, decimalPtQuotient = 0xFF;
// char prevMostSigQuotient, prevLeastSigQuotient, prevDecimalPtQuotient;
// 
// divisor = 0;
// do {
//      divisor++;
//      prevMostSigQuotient = mostSigQuotient;
//      prevLeastSigQuotient = leastSigQuotient;
//      prevDecimalPtQuotient = decimalPtQuotient;
//      mostSigQuotient, leastSigQuotient, decimalQuotient = divide(mostSig, leastSig, divisor);
// } while (mostSigQuotient > 0 || leastSigQuotient > divisor || (leastSigQuotient == divisor && decimalPtQuotient > 0) );
// return divisor;

// Register / Memory mapping
// divisor:                 $t2     M[22]
// mostSigQuotient:         $t3     M[23]
// leastSigQuotient:        $t4     M[24]
// decimalPtQuotient:       $t5     M[25]
// prevMostSigQuotient:     $t6     M[26]
// prevLeastSigQuotient:    $t7     M[27]
// prevDecimalPtQuotient:   $t8     M[28]

// mostSig
// divisor = 0
move    0
store   0   $t2

// mostSigQuotient($t3) = 0xFF
move    0
neg     
store   0   $t3  

// leastSigQuotient($t4) = 0xFF
move    0
neg     
store   0   $t4

// decimalPtQuotient($t5) = 0xFF
move    0
neg     
store   0   $t5

// SET PARAMETER FOR PROGRAM 2
// M[0] = M[16](mostSig)
move    0
store   0   $t10
move    16
store   0   $t11
load    1   $t11
store   1   $t10

// M[1] = M[17](leastSig)
move    1
store   0   $t10
move    17
store   0   $t11
load    1   $t11
store   1   $t10

DoWhile:
    // prevMostSigQuotient($t6) = mostSigQuotient($t3);
    load    0   $t3
    store   0   $t6

    // prevLeastSigQuotient($t7) = leastSigQuotient($t4);
    load    0   $t4
    store   0   $t7

    // prevDecimalPtQuotient($t8) = decimalPtQuotient($t5);
    load    0   $t5
    store   0   $t8

    // divisor++
    load    0   $t2
    add     0   1
    store   0   $t2
    
    // M[2] = divisor
    move    2
    store   0   $t10
    load    0   $t2
    store   1   $t10
    
    // SAVE REGISTER INTO MEMORY before running program 2
        // save divisor($t2)
        move    2
        store   0   $t10
        load    0   $t2
        store   1   $t10

        // save prevMostSigQuotient($t6)
        move    6
        store   0   $t10
        load    0   $t6
        store   1   $t10

        // save prevLeastSigQuotient($t7)
        move    7
        store   0   $t10
        load    0   $t7
        store   1   $t10

        // save prevDecimalPtQuotient($t8)
        move    8
        store   0   $t10
        load    0   $t8
        store   1   $t10

    // RUN PROGRAM 2 

    // FINISH RUNNING PROGRAM 2

    // RESTORE registers
        // restore divisor($t2)
        move    2
        store   0   $t10
        load    1   $t10
        store   0   $t2

        // restore prevMostSigQuotient($t6)
        move    6
        store   0   $t10
        load    1   $t10
        store   0   $t6

        // restore revLeastSigQuotient($t7)
        move    7
        store   0   $t10
        load    1   $t10
        store   0   $t7

        // restore revDecimalPtQuotient($t8)
        move    8
        store   0   $t10
        load    1   $t10
        store   0   $t8

    // store result from program 2
        // mostSigQuotient($t3) = M[4]
        move    4
        store   0   $t10
        load    1   $t10
        store   0   $t3

        // leastSigQuotient($t4) = M[5]
        move    5
        store   0   $t10
        load    1   $t10
        store   0   $t4

        // decimalQuotient($t5) = M[6]
        move    6
        store   0   $t10
        load    1   $t10
        store   0   $t5

    // } while (mostSigQuotient > 0 || leastSigQuotient > divisor || (leastSigQuotient == divisor && decimalPtQuotient > 0) );
        // if (mostSigQuotient($t3) > 0) jump to DoWhile
        load    0   $t3
        sgt     0   0
        bne     DoWhile

        // if (leastSigQuotient($t4) > divisor($t2)) jump to DoWhile
        load    0   $t4
        sgt     1   $t2
        bne     DoWhile
        
        // if (leastSigQuotient == divisor && decimalPtQuotient > 0) jump to DoWhile
            // $t10 = (leastSigQuotient($t4) == divisor($t2))
            load    0   $t4
            seq     1   $t2
            store   0   $t10

            // $t11 = (decimalPtQuotient($t5) > 0)
            load    0   $t5
            sgt     0   0
            store   0   $t11
            
            // if ($t10 & $t11) jump to DoWhile
            load    0   $t10
            sand    1   $t11
            bne     DoWhile
            
// return divisor
// M[18] = divisor
move    18
store   0   $t10
load    0   $t2
store   1   $t10


// // MORE PRECISE IMPLEMENTATION
// // char is 1 byte (8 bits)
// char mostSig, leastSig, decimalPt;
// char divisor = 1;
// char mostSigQuotient, leastSigQuotient, decimalPtQuotient;
// char prevMostSigQuotient, prevLeastSigQuotient, prevDecimalPtQuotient;
// // 
// mostSigQuotient, leastSigQuotient, decimalQuotient = divide(mostSig, leastSig, decimalPt, divisor);
// while (mostSigQuotient > 0 || leastSigQuotient > divisor || (leastSigQuotient == divisor && decimalPt > 0) ) {
//      divisor++;
//      prevMostSigQuotient = mostSigQuotient;
//      prevLeastSigQuotient = leastSigQuotient;
//      prevDecimalPtQuotient = decimalPtQuotient;
//      mostSigQuotient, leastSigQuotient, decimalQuotient = divide(mostSig, leastSig, decimalPt, divisor);
// }
// char decimalPtDiff = 1 - decimalPtQuotient;
// char leastSigDiff = (decimalPtQuotient > 0) ? divisor - leastSigQuotient - 1 : divisor - leastSigQuotient;
// char prevDecimalPtDiff = prevDecimalPtQuotient;
// char prevLeastSigDiff = prevLeastSigQuotient - divisor - 1;
// if (leastSigDiff < prevLeastSigDiff || ((leastSigDiff == prevLeastSigDiff) && (decimalPtDiff < prevDecimalPtDiff))) {
//      return divisor;
// } else {
//      return divisor-1;
// } 



